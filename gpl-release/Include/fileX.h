// SPDX-License-Identifier: GPL-3.0-or-later
/*
 *   This file was automatically generated by version 1.5 of cextract.
 *   Manual editing not recommended.
 *
 *   Created: Tue Oct 20 18:12:09 1992
 */
#ifndef __CEXTRACT__
#if __STDC__
#define PL_(x) x
#else
#define PL_(x) ( )
#endif /* __STDC__ */

/* checkX.c: This file performs locking, error and status checking */

/* CHECK_LOCK -- Set/Check lock on a file... return -1 if already active
                 set keeplock to true to set lock after checking */
extern int check_lock PL_(( char * filename, int keeplock ));

/* GET_USERID -- Find the user name if possible */
extern char * get_userid PL_(( char * outname ));

/* KILL_LOCK -- Remove a previously set lock, by number */
extern void kill_lock PL_(( int fid, char * fname ));

/* USER_EXISTS -- Returns TRUE if user is a valid name of the system */
extern int user_exists PL_(( char * who ));

/* VERIFY_DATA -- Verify all of the data */
extern void verify_data PL_(( char * __file__, int __line__ ));

/* VERIFY_NTN -- assure that information for all nations is valid */
extern void verify_ntn PL_(( char * __file__, int __line__ ));

/* VERIFY_SCT -- Assure that all sectors contain valid information */
extern void verify_sct PL_(( char * __file__, int __line__ ));

/* WHO_IS_ON -- Routine to list all users currently logged in */
extern void who_is_on PL_(( void ));

/* computeX.c: Routines for calculating national production, budget and stats */

/* ADJUST_ATTRIBUTE -- Shift a given national attribute by a given amount */
extern void adjust_attribute PL_(( short * bute_list, int butenum, int amount ));

/* ADJUST_PRODUCTION -- Adjustment of produced raw materials */
extern void adjust_production PL_(( SHEET_PTR produce_ptr, int fullinfo ));

/* ARMY_REORGANIZE -- Reorganize all of the unit numbers */
extern void army_reorganize PL_(( void ));

/* ATTRACT_VAL -- The attractiveness of a particular sector */
extern int attract_val PL_(( int xloc, int yloc ));

/* DFLT_CITYWEIGHT -- Determine the default weighting value */
extern int dflt_cityweight PL_(( int ntnnum, CITY_PTR c1_ptr ));

/* FIND_AREA -- This routine sets the limit indicators for a nation */
extern void find_area PL_(( int ntnnum ));

/* FIND_NEWARMYNUM -- Determine a new army unit number by the given utype */
extern int find_newarmynum PL_(( int utype ));

/* INFL_OF -- computer the inflation expense on some talons */
extern itemtype infl_of PL_(( itemtype talon_value ));

/* MERC_COSTRATE -- % of going rate that the current nation pays for mercs */
extern int merc_costrate PL_(( void ));

/* MGK_COST_ADJUST -- Just account for the adjustment of normal expensive */
extern void mgk_cost_adjust PL_(( int type, itemtype * expenses ));

/* NTN_TOTALS -- Gather together all of the city and item information */
extern void ntn_totals PL_(( int nation ));

/* R10_REGION -- Determine the supply range (x10) of the supply center */
extern int r10_region PL_(( NTN_PTR n1_ptr, CITY_PTR c1_ptr, SCT_PTR s1_ptr ));

/* REGION_CONSUME -- Calculate amount consumed from city resources */
extern SHEET_PTR region_consume PL_(( char * cname, int fullinfo ));

/* REGION_PRODUCE -- Calculate amount produced within communication range */
extern SHEET_PTR region_produce PL_(( char * cname, int fullinfo ));

/* SET_WEIGHTS -- Set distribution weights for nation */
extern void set_weights PL_(( int recalc ));

/* convertX.c: various routines to change one thing into another */

/* CHAR_IN_STR -- function to check if a character is in a character array */
extern int char_in_str PL_(( char ch, char * str ));

/* COMPLETION -- Returns TRUE if second string is a possible
                 completion of the first.  Aka stncmp(a,b,strlen(a)) */
extern int completion PL_(( char * s1, char * s2 ));

/* CONVERT_KBIND -- Convert the textual keybinding to an actual keybinding */
extern void convert_kbind PL_(( char * str ));

/* FORM_STR -- Create a string of characters for later use */
extern void form_str PL_(( char * out_str, char * in_str, int full ));

/* LIST_MAGICS -- List any magic powers encountered into a string */
extern int list_magics PL_(( char * out_str, int mcls, long powlist ));

/* NON_CNTRL -- return the non-control value of a control character */
extern int non_cntrl PL_(( int ch ));

/* NTN_REALNAME -- Find the proper name for a nation */
extern int ntn_realname PL_(( char * outstr, int who ));

/* POPTOWORKERS -- Determine the number of workers based on population */
extern long poptoworkers PL_(( long population ));

/* ROMAN_BASE -- Return the nearest base value I,V,X,... etc.
                 note that 4 => 5, 9 => 10, 40 => 50, etc.    */
extern int roman_base PL_(( int value ));

/* ROMAN_NUMBER -- This routine places a string containing the roman
                   numeral representation of a number.               */
extern void roman_number PL_(( char * str, int value ));

/* TO_CNTRL -- return the control value of a non-control character */
extern int to_cntrl PL_(( int ch ));

/* TRIM_STR -- remove blank space, and comments if so desired */
extern int trim_str PL_(( char * str, int killpound ));

/* XLOC_RELATIVE -- return X value relative to centralize location */
extern int xloc_relative PL_(( int given_xloc ));

/* YLOC_RELATIVE -- return Y value relative to centralize location */
extern int yloc_relative PL_(( int given_yloc ));

/* customX.c: simple routines to allow read and write a configuration file */

/* INIT_DATADIR -- Assign the value of datadir based on datadirname */
extern void init_datadir PL_(( void ));

/* READ_CUSTOM -- This function reads in the list of conquer options */
extern int read_custom PL_(( char * f_str ));

/* READ_ENVIRON -- Parse the environment variable used by conquer */
extern void read_environ PL_(( void ));

/* executeX.c: This file reads in player commands from the execute file */

/* EXECUTE -- Read in the commands entered using the conquer interface
              Returns 0 for no file, 1 for success, > or -1 for errors */
extern int execute PL_(( int cntry ));

/* hexmapX.c: This file contains hexmap routines relevent to all of conquer */

/* MAP_LOOP -- Perform a loop of range of N around given sector;
               The provided function is called for each sector found */
extern void map_loop PL_(( int xcent, int ycent, int range, FNCV2 perform_func ));

/* MAP_WITHIN -- Are the two locations within the given range? */
extern int map_within PL_(( int xa, int ya, int xb, int yb, int range ));

/* ioX.c: This file handles most generic input/output commands */

/* BOTTOMMSG -- Display a message, without waiting for any keystroke */
extern void bottommsg PL_(( char * str ));

/* CLEAR_BOTTOM -- Empty out the message area on bottom of screen */
extern void clear_bottom PL_(( int l ));

/* CQ_BYE -- Call cq_reset() and exit program with supplied status */
extern void cq_bye PL_(( int status ));

/* CQ_INIT -- Initialize the curses display */
extern void cq_init PL_(( char * progname ));

/* CQ_RESET -- Terminate the curses display gracefully */
extern void cq_reset PL_(( void ));

/* CR_OR_Y -- Return TRUE for 'y' or 'Y' character press */
extern int cr_or_y PL_(( void ));

/* DO_REDRAW -- Alternative method of refreshing the screen */
extern int do_redraw PL_(( void ));

/* ERRORBAR -- function to display a highlighted region at screen bottom */
extern void errorbar PL_(( char * str1, char * str2 ));

/* ERRORMSG -- Display a message and wait for a keystroke */
extern int errormsg PL_(( char * str ));

/* FORK_EDIT_ON_FILE -- execute an edit on a file copy, then copy in */
extern void fork_edit_on_file PL_(( char * fname, char * pstr ));

/* GET_ACLASS -- Return an army class; AC_NUMBER on invalid input */
extern int get_aclass PL_(( void ));

/* GET_ATYPE -- Return an army type interactively;
                   num_armytypes indicates invalid input  */
extern int get_atype PL_(( void ));

/* GET_DOUBLE -- Read a double; Set no_input for just carriage return */
extern double get_double PL_(( int allowneg ));

/* GET_MONTH -- Return a month interactively */
extern int get_month PL_(( void ));

/* GET_NUMBER -- Read an integer; Set no_input for just carriage return */
extern long get_number PL_(( int allowneg ));

/* GET_OPTION -- Enter a possible option string */
extern int get_option PL_(( void ));

/* GET_PASS -- Enter a string without echoing; Return length */
extern int get_pass PL_(( char * str ));

/* GET_SPEED -- Return a speed value interactively */
extern int get_speed PL_(( void ));

/* GET_STATUS -- Return a status value interactively */
extern int get_status PL_(( void ));

/* GET_STRING -- Read in a string of characters; Return length < NAMELTH
                 The parameter stype indicates type of input requested.
		 Return -1 and exit for escape key */
extern int get_string PL_(( char * str, int stype, int max_len ));

/* HIP_STRING -- Highlight a character in parenthesis on true */
extern void hip_string PL_(( char * str_in, int keychar, int bolden ));

/* NEXT_CHAR -- Obtain the next character of input */
extern int next_char PL_(( void ));

/* ONE_CHAR -- get one character which is contained in the given set */
extern int one_char PL_(( char * set, int fold ));

/* PRESSKEY -- Display message, refresh, get key, clear last line */
extern int presskey PL_(( void ));

/* PUSH_CHAR -- Store input on the stack */
extern void push_char PL_(( int ch_in ));

/* SHOW_CHAR -- Show a character to the current position */
extern void show_char PL_(( char ch, int full ));

/* SHOW_STR -- Display the entire string at the current location */
extern void show_str PL_(( char * str, int full ));

/* UNSHOW_CHAR -- Remove a character from the current position */
extern void unshow_char PL_(( char ch, int full ));

/* WIN_SIZE_CHANGE -- signal handler for window size change */
extern void win_size_change PL_(( int sig ));

/* Y_OR_N -- Return TRUE for 'y' or 'Y' character press */
extern int y_or_n PL_(( void ));

/* iodataX.c: This source file contains code to read and write the data file */

/* EXISTS -- test for the existance of a file */
extern int exists PL_(( char * file ));

/* FPUT_STRING -- routine to check routine value of fputs */
extern void fput_string PL_(( char * outstr, FILE * filep ));

/* MOVE_FILE -- Rename a file; non-zero on failure.
                implementation suggested by Jerry Pierce */
extern int move_file PL_(( char * from, char * to ));

/* READ_DATA -- Routine to read world information from a data file */
extern int read_data PL_(( void ));

/* SYSERR_MSG -- Try to make use of perror if the system has it */
extern void syserr_msg PL_(( char * estr ));

/* WRITE_DATA -- Routine to store the user information in a data file */
extern void write_data PL_(( void ));

/* magicX.c: This file handles magic power enhancement and spell results */

/* ADD_POWERS -- Provide enhancment from list of magic powers */
extern void add_powers PL_(( int powtype, long powlist ));

/* KILL_POWERS -- Remove enhancment from list of magic powers */
extern void kill_powers PL_(( int powtype, long powlist ));

/* MAGIC_OK -- Is the new magic power possible, for the given class? */
extern int magic_ok PL_(( int magic_type, int new_mint ));

/* MGK_SCTVAL -- Magical combat bonus for a given sector */
extern int mgk_sctval PL_(( NTN_PTR n1_ptr, int x, int y ));

/* RAND_MAGIC -- Assign a random magical power; return power if successful */
extern long rand_magic PL_(( int magic_type ));

/* mailX.c: formating routines for mail messages */

/* DELIVER_MAIL -- Send the current mail message to the indicated countries */
extern void deliver_mail PL_(( void ));

/* FREE_MAIL -- Deallocate all of the current mail memory in use */
extern void free_mail PL_(( void ));

/* INIT_MAIL -- Initialize the storage structure for the current message */
extern void init_mail PL_(( void ));

/* KILL_MAIL -- Remove the currently pointed to mail message from the list */
extern void kill_mail PL_(( void ));

/* MAIL_HEADER -- Send a mail header to the current target */
extern void mail_header PL_(( char * nnstr, char * nkstr, char * subj, char * dstr, int statval ));

/* memoryX.c: This file handles mallocing, sorting and other memory dohickys */

/* ALIGN_ARMYNEAR -- Assign location pointers properly */
extern void align_armynear PL_(( void ));

/* ALIGN_DATA -- Destroy nations and count elements */
extern void align_data PL_(( void ));

/* ARMY_SORT() -- Resort army list into ascending order and connect
                  armies in same sector by the near structure       */
extern void army_sort PL_(( int skipnears ));

/* CITY_SORT() -- Resort city list into ascending order */
extern void city_sort PL_(( void ));

/* CLR_MEMORY -- Clear out a patch of memory */
extern void clr_memory PL_(( char * mem_ptr, int len ));

/* CRT_ARMY -- Build an army unit assigning an id number to it
                  based on the type of the new unit.              */
extern ARMY_PTR crt_army PL_(( int utype ));

/* CRT_CITY -- Add a new city to the nation city list */
extern CITY_PTR crt_city PL_(( char * cname ));

/* CRT_CVN -- Add a new caravan to the nation list */
extern CVN_PTR crt_cvn PL_(( void ));

/* CRT_DMODE -- Initialize a new display mode into display mode list */
extern DMODE_PTR crt_dmode PL_(( char * dmodename ));

/* CRT_ITEM -- Add a new item to the nation list */
extern ITEM_PTR crt_item PL_(( void ));

/* CRT_NAVY -- Add a new navy to the nation list */
extern NAVY_PTR crt_navy PL_(( void ));

/* CRT_NTN -- Initialize a new nation into the world */
extern NTN_PTR crt_ntn PL_(( char * ntnname, int actval ));

/* CVN_SORT() -- Resort caravan list into ascending order */
extern void cvn_sort PL_(( void ));

/* DEST_ARMY -- Remove an army unit from the army list */
extern void dest_army PL_(( int idnum ));

/* DEST_CITY -- Remove a city from the national city list */
extern void dest_city PL_(( char * cname ));

/* DEST_CVN -- Remove a caravan from the caravan list */
extern void dest_cvn PL_(( int idnum ));

/* DEST_ITEM -- Remove an item from the national commodity list */
extern void dest_item PL_(( int idnum ));

/* DEST_NAVY -- Remove a navy unit from the navy list */
extern void dest_navy PL_(( int idnum ));

/* DEST_NTN -- This routines frees up the memory associated with a
                  nation structure.                                   */
extern void dest_ntn PL_(( char * nname ));

/* ITEM_SORT() -- Resort item list into ascending order */
extern void item_sort PL_(( void ));

/* M2ALLOC -- Allocate a two dimensional array of memory
              nrows: number of rows, ncols: number of columns
              entrysize: number of bytes in a unit            */
extern char ** m2alloc PL_(( int nrows, int ncols, int entrysize ));

/* NAVY_SORT() -- Resort navy list into ascending order */
extern void navy_sort PL_(( void ));

/* NEW_ARMY -- Allocate space for a new army unit */
extern ARMY_PTR new_army PL_(( void ));

/* NEW_CITY -- Allocate space for a new city */
extern CITY_PTR new_city PL_(( void ));

/* NEW_CVN -- Allocate space for a new cvn unit */
extern CVN_PTR new_cvn PL_(( void ));

/* NEW_DMODE -- Allocate space for a new display entry */
extern DMODE_PTR new_dmode PL_(( void ));

/* NEW_ITEM -- Allocate space for a new item */
extern ITEM_PTR new_item PL_(( void ));

/* NEW_MAP -- Allocate space for a new unit mapping structure */
extern MAP_PTR new_map PL_(( void ));

/* NEW_MAPCHAR -- Allocate character memory the size of the world */
extern char * new_mapchar PL_(( char * mem_ptr ));

/* NEW_MAPLONG -- Allocate long integer memory the size of the world */
extern long * new_maplong PL_(( long * mem_ptr ));

/* NEW_MAPSHORT -- Allocate short integer memory the size of the world */
extern short * new_mapshort PL_(( short * mem_ptr ));

/* NEW_NAVY -- Allocate space for a new naval unit */
extern NAVY_PTR new_navy PL_(( void ));

/* NEW_NTN -- Allocate space for a new nation */
extern NTN_PTR new_ntn PL_(( void ));

/* NEW_UNUM -- Allocate space for a new unit numbering structure */
extern UNUM_PTR new_unum PL_(( void ));

/* NTN_SORT -- This routine places the nations in alphabetical order
               and gets rid of any empty slots.                      */
extern void ntn_sort PL_(( void ));

/* UNUM_DEFAULTS -- Set the default values */
extern void unum_defaults PL_(( void ));

/* miscX.c: This file contains miscellaneous functions used in both programs */

/* GIVE_SPELLCASTERS -- Generate spell casters for each nation */
extern void give_spellcasters PL_(( void ));

/* HL_TARGETS -- Does the highlight method need a target value */
extern int hl_targets PL_(( int style ));

/* MACH_TIME -- Return a pointer to a string containing the date */
extern char * mach_time PL_(( void ));

/* MARKOK -- Is the nation mark valid?  If so, return TRUE */
extern int markok PL_(( int mark, int racetype, int showwhy ));

/* NRAND_SEED -- Set the storage value for the nrand_val() function */
extern void nrand_seed PL_(( void ));

/* NRAND_VAL -- Adjusted random value to gain the same results each time */
extern long nrand_val PL_(( long limit, long adj ));

/* NUM_BITS_ON -- Return the number of active bits in the given long */
extern int num_bits_on PL_(( long lng_list ));

/* RAND_SEED -- Seed the random number generator */
extern void rand_seed PL_(( void ));

/* RAND_TGOOD -- Select a random tradegood of given class of > min value */
extern int rand_tgood PL_(( int tg_class, int minval ));

/* RAND_VAL -- This routine is used for generating a random number
               from 0 to N - 1.                                    */
extern long rand_val PL_(( int limit ));

/* STR_NTEST -- This function is basically a casefolding strncmp */
extern int str_ntest PL_(( char * s1, char * s2, int num ));

/* STR_TEST -- This function is basically a casefolding strcmp */
extern int str_test PL_(( char * s1, char * s2 ));

/* moveX.c: routines concerning the relocation of units between sectors */

/* MOVE_COST -- Routine to calculate the move cost for a specified unit type */
extern int move_cost PL_(( int x, int y, int type ));

/* SET_MOVEPOTENTIAL -- Set the movement potential for a unit */
extern void set_movepotential PL_(( int type ));

/* sectorX.c: Routines concerning sector adjustment and reading are in this file */

/* DEFENSE_VAL -- Compute the defensive value for a sector */
extern int defense_val PL_(( int x, int y ));

/* DESG_OK -- Determine if the major designation is valid for the sector */
extern int desg_ok PL_(( int x, int y, int dtype, int verbal ));

/* DISTORT_VISION -- Distort numerical values based on vision of a sector */
extern long distort_vision PL_(( int xval, int yval, long trueval, long distval ));

/* EXPOSURE_VALUE -- The amount of exposure troops face in a sector */
extern int exposure_value PL_(( NTN_PTR n1_ptr, SCT_PTR s1_ptr ));

/* FIND_RESOURCES -- Build an item_struct holding all nearby resources */
extern ITEM_PTR find_resources PL_(( int xloc, int yloc, int insect_only ));

/* FORT_VAL -- Compute the fortification value of a sector */
extern int fort_val PL_(( int x, int y ));

/* GETJEWEL -- Assign value and type to a sector's jewels */
extern void getjewel PL_(( SCT_PTR sptr ));

/* GETMETAL -- Assign a metal value to a given sector */
extern void getmetal PL_(( SCT_PTR sptr ));

/* GETSPELL -- Assign magic spell enchantment sectors */
extern void getspell PL_(( SCT_PTR sptr ));

/* IS_HABITABLE -- Determine if a sector can be lived in */
extern int is_habitable PL_(( int x, int y ));

/* JEWEL_VALUE -- Return the value of the jewels in the sector */
extern int jewel_value PL_(( SCT_PTR sptr ));

/* MAGIC_VALUE -- Return the value of the spells in the sector */
extern int magic_value PL_(( SCT_PTR sptr ));

/* MAJDESG_COSTS -- Calculate the resource price to build a selection */
extern ITEM_PTR majdesg_costs PL_(( int which, int x, int y, int verbal ));

/* METAL_VALUE -- Return the value of the metals in the sector */
extern int metal_value PL_(( SCT_PTR sptr ));

/* MINDESG_COSTS -- Compute the cost for the minor designation */
extern ITEM_PTR mindesg_costs PL_(( int which, int x, int y, int verbal ));

/* MINDESG_OK -- Check if a minor designation is valid for a sector */
extern int mindesg_ok PL_(( int x, int y, int mdtype, int verbal ));

/* RAND_SECTOR -- Set the global int and global longs to a random locale */
extern void rand_sector PL_(( int x, int y, int range, int nowater, int visionrand ));

/* SCT_COST_ADJUST -- Adjustment due to what is in the sector */
extern void sct_cost_adjust PL_(( int type, SCT_PTR s1_ptr, itemtype * expenses ));

/* SECTOR_CONSUME -- Calculate all of the sector needs */
extern void sector_consume PL_(( int xloc, int yloc, SHEET_PTR out_ptr ));

/* SECTOR_PRODUCE -- Calculate all of the production ability */
extern void sector_produce PL_(( int xloc, int yloc, SHEET_PTR out_ptr ));

/* SEND_RESOURCES -- Redistribute materials to nearby supply centers */
extern int send_resources PL_(( int xloc, int yloc, ITEM_PTR give_ptr, int insect ));

/* S_USELEVEL -- Usage level of the sector within it's discipline */
extern int s_uselevel PL_(( SCT_PTR s1_ptr ));

/* TAKE_RESOURCES -- Remove resources from neighoring areas */
extern int take_resources PL_(( int xloc, int yloc, ITEM_PTR take_ptr, int insect ));

/* TG_OK -- TRUE if a trade good can be seen by the given nation */
extern int tg_ok PL_(( SCT_PTR sptr, int nation ));

/* TOFOOD -- Compute the food value of a sector */
extern int tofood PL_(( SCT_PTR sptr, int cntry ));

/* TOWOOD -- Compute the lumber value of a sector */
extern int towood PL_(( SCT_PTR sptr, int cntry ));

/* selectX.c: This file provides quick reference to data structures */

/* ARMYBYNUM -- Retrieve pointer to a given army number */
extern ARMY_PTR armybynum PL_(( int idnum ));

/* CITYBYLOC -- Check for a city by location */
extern CITY_PTR citybyloc PL_(( NTN_PTR n1_ptr, int x, int y ));

/* CITYBYNAME -- Check for a city by name */
extern CITY_PTR citybyname PL_(( char * str ));

/* CVNBYNUM -- Retrieve pointer to a given caravan number */
extern CVN_PTR cvnbynum PL_(( int idnum ));

/* ITEMBYARMY -- Search for the army number in the item list */
extern ITEM_PTR itembyarmy PL_(( int idnum ));

/* ITEMBYCVN -- Search for the caravan number in the item list */
extern ITEM_PTR itembycvn PL_(( int idnum ));

/* ITEMBYNAVY -- Search for the navy number in the item list */
extern ITEM_PTR itembynavy PL_(( int idnum ));

/* ITEMBYNUM -- Retrieve a commodity by its given number */
extern ITEM_PTR itembynum PL_(( int idnum ));

/* ITEMBYSCT -- Find the next item pointer to a sector */
extern ITEM_PTR itembysct PL_(( ITEM_PTR i_list, int x, int y, int type ));

/* NAVYBYNUM -- Retrieve pointer to a given navy number */
extern NAVY_PTR navybynum PL_(( int idnum ));

/* NTNBYNAME -- Check for a nation by name or number */
extern NTN_PTR ntnbyname PL_(( char * str ));

/* UCLASSBYNAME -- Retrieve a unit class by the name string */
extern int uclassbyname PL_(( char * match_str ));

/* UNITBYNAME -- Retrieve a unit number by the name string */
extern int unitbyname PL_(( char * match_str ));

/* unitsX.c: Misc. manipulation routines for army, navy and caravan units */

/* ARMIES_IN_SECTOR -- Report the number of army units in a sector */
extern int armies_in_sector PL_(( int natn, int xloc, int yloc ));

/* ARMY_CAPTSIZE -- Strength of the unit in relation to sector taking */
extern long army_captsize PL_(( ARMY_PTR a1_ptr, int takefigure ));

/* ARMY_LOAD -- The amount of load within an army unit */
extern long army_load PL_(( ARMY_PTR a_ptr ));

/* ARMY_MVPTS -- Return the starting movement for the specified unit */
extern int army_mvpts PL_(( NTN_PTR n1_ptr, ARMY_PTR a1_ptr ));

/* ARMY_RENUM -- Renumber the current army unit in the current nation */
extern void army_renum PL_(( int newnum ));

/* ARMY_SHIPLEADER -- Return leader if onboard otherwise EMPTY_HOLD */
extern int army_shipleader PL_(( ARMY_PTR a1_ptr ));

/* ARMY_SPELLPTS -- How many spell points maximum should a unit get? */
extern int army_spellpts PL_(( NTN_PTR n1_ptr, ARMY_PTR a1_ptr ));

/* ARMY_SUPPORT -- Calculate the support costs for an army unit */
extern void army_support PL_(( ARMY_PTR a1_ptr, itemtype * out_costs, int amount ));

/* ARMY_WORKSIZE -- Strength of the unit in relation to building potential */
extern long army_worksize PL_(( ARMY_PTR a1_ptr ));

/* A_ISSUPPLYABLE -- Determine if a unit is or is not supplyable from x, y */
extern int a_issupplyable PL_(( ARMY_PTR a1_ptr, int x, int y, int sayit ));

/* CARGO_HOLDS -- The number of holds in the given ship information */
extern int cargo_holds PL_(( int shipinfo ));

/* CHECK_LEADER -- return TRUE or FALSE if a leader is really leading */
extern int check_leader PL_(( int idnum ));

/* CVNS_IN_SECTOR -- Report the number of caravans in a sector */
extern int cvns_in_sector PL_(( int natn, int xloc, int yloc ));

/* CVN_CARRYING -- Return TRUE if the given unit has something onboard */
extern int cvn_carrying PL_(( CVN_PTR c1_ptr ));

/* CVN_LOAD -- The amount of load within a caravan unit;
               This will need to later have mtrls weight added */
extern long cvn_load PL_(( CVN_PTR v_ptr ));

/* CVN_MVPTS --  Find speed of caravan */
extern int cvn_mvpts PL_(( NTN_PTR nat_ptr, CVN_PTR c_ptr ));

/* CVN_REDOCOSTS -- Calculate the repair costs for the caravan */
extern void cvn_redocosts PL_(( CVN_PTR v1_ptr, itemtype * out_costs ));

/* CVN_RENUM -- Renumber the current caravan unit in the current nation */
extern void cvn_renum PL_(( int newnum ));

/* CVN_SUPPORT -- Calculate the supply levels for a caravan */
extern void cvn_support PL_(( CVN_PTR v1_ptr, itemtype * out_costs, int amount ));

/* DEFAULTUNIT -- Selection of the default unit for drafting */
extern int defaultunit PL_(( void ));

/* GETMINLEADER -- Return the minor leader for the national class */
extern int getminleader PL_(( int class ));

/* GETRULER -- Return the major leader for the national class */
extern int getruler PL_(( int class ));

/* GROUP_STAT -- Return the status of the given group */
extern int group_stat PL_(( int idnum ));

/* HEAL_RATE -- The percentage of health healed for an army unit */
extern int heal_rate PL_(( NTN_PTR n1_ptr, ARMY_PTR a1_ptr ));

/* MAIN_LEADER -- Get the setting of the guy at the front of a group */
extern ARMY_PTR main_leader PL_(( int idnum ));

/* MAKE_MADUNIT -- Create an army of given type size and location */
extern int make_madunit PL_(( int own, int atype, int asize, int axloc, int ayloc ));

/* MAX_NUMUNIT -- Return the value of the number of men possible */
extern long max_numunit PL_(( NTN_PTR n1_ptr, CITY_PTR c1_ptr, int utype, int spts ));

/* MAY_UPGRADE -- Is the army unit able to be upgraded? */
extern int may_upgrade PL_(( NTN_PTR n1_ptr, CITY_PTR c1_ptr, int utype, int men ));

/* MEN_INGARRISON -- Return the number of men garrisoned in the sector */
extern long men_ingarrison PL_(( int x, int y, int onlyaair ));

/* MEN_INGROUP -- Return the number of soldiers in a given group */
extern int men_ingroup PL_(( int idnum, int onlyaair ));

/* MTRLS_LOAD -- Return the value of the load of a set of raw materials */
extern long mtrls_load PL_(( itemtype * m_ptr ));

/* NAVIES_IN_SECTOR -- Report the number of naval units in a sector */
extern int navies_in_sector PL_(( int natn, int xloc, int yloc ));

/* NAVY_ADDSHIPS -- increase element by nships of given type
                    return resulting element or -1 for failure */
extern int navy_addships PL_(( uns_short info, int sh_size, int nships ));

/* NAVY_CARRYING -- Return TRUE if the given unit has something onboard */
extern int navy_carrying PL_(( NAVY_PTR n1_ptr ));

/* NAVY_HOLDS -- The number of holds among a class of ships in a given fleet */
extern int navy_holds PL_(( NAVY_PTR n1_ptr, int classnum ));

/* NAVY_MVPTS --  Find speed of naval fleet */
extern int navy_mvpts PL_(( NTN_PTR nat_ptr, NAVY_PTR nvy_ptr ));

/* NAVY_REDOCOSTS -- Calculate the repair costs for the navy */
extern void navy_redocosts PL_(( NAVY_PTR n1_ptr, itemtype * out_costs ));

/* NAVY_RENUM -- Renumber the current navy unit in the current nation */
extern void navy_renum PL_(( int newnum ));

/* NAVY_SUBSHIPS -- remove nships of given shipsize for a given fleet
                    return result or -1 if it is not possible */
extern int navy_subships PL_(( uns_short info, int sh_size, int nships ));

/* NAVY_SUPPORT -- Calculate the supply levels for a naval unit */
extern void navy_support PL_(( NAVY_PTR n1_ptr, itemtype * out_costs, int amount ));

/* NEWSLOTNUMBER -- set the default number to the given value */
extern void newslotnumber PL_(( int base, int idnum, int numtype ));

/* N_ISSUPPLYABLE -- Determine if a unit is or is not supplyable from x, y */
extern int n_issupplyable PL_(( NAVY_PTR n1_ptr, int x, int y, int sayit ));

/* RAND_MONSTUNIT -- Give random monster unit as limited by size */
extern int rand_monstunit PL_(( int maxstrength ));

/* REAL_STAT -- Return the real status of the army unit */
extern int real_stat PL_(( ARMY_PTR a1_ptr ));

/* RESETNUMBERS -- Clear out the default numbering scheme */
extern void resetnumbers PL_(( void ));

/* SET_ARMYCOSTS -- Set the costs of the given unit of given size */
extern void set_armycosts PL_(( NTN_PTR n1_ptr, itemtype * cost_ptr, int type, int size ));

/* SET_GRPLOC -- Assign a given location to an entire group */
extern void set_grploc PL_(( int idnum, int x, int y ));

/* SET_GRPMOVE -- Assign a given movement to an entire group */
extern void set_grpmove PL_(( int idnum, int speed, int mval ));

/* SET_UPGCOSTS -- Set the to upgrade to the given unit of given size */
extern void set_upgcosts PL_(( NTN_PTR n1_ptr, ARMY_PTR a1_ptr, itemtype * cost_ptr, int newtype ));

/* SHIPS_IN_SECTOR -- Retrun the number of ships in a given sector */
extern int ships_in_sector PL_(( int x, int y ));

/* STARTNUMBER -- Assign a starting number using the given string */
extern int startnumber PL_(( char * str, char * estr ));

/* START_UNITSPLY -- Return the standard starting supply value for new units */
extern int start_unitsply PL_(( void ));

/* UNITS_IN_SECTOR -- return the number of armies, caravans, and
                      navies in a sector for a nation.           */
extern int units_in_sector PL_(( int natn, int x, int y ));

/* UNIT_BASENUM -- Determine the base unit number of a unit */
extern int unit_basenum PL_(( int utype ));

/* UNUM_COPYDEFAULT -- Copy the default numbering scheme */
extern void unum_copydefault PL_(( void ));

/* UTYPE_MAYUSE -- Check if the given unit type may be used by the nation */
extern int utype_mayuse PL_(( NTN_PTR n1_ptr, int utype ));

/* UTYPE_OK -- Check if the given unit type is okay for the current city */
extern int utype_ok PL_(( NTN_PTR n1_ptr, CITY_PTR c1_ptr, int utype, int upg_men, int eout ));

/* V_ISSUPPLYABLE -- Determine if a unit is or is not supplyable from x, y */
extern int v_issupplyable PL_(( CVN_PTR v1_ptr, int x, int y, int sayit ));

/* WAGONS_IN_SECTOR -- Return the number of caravan wagons in a given sector */
extern int wagons_in_sector PL_(( int x, int y ));

/* WALL_PATROL -- Is an army unit acting as a wall patrol? */
extern int wall_patrol PL_(( int cntry, ARMY_PTR a1_ptr ));

/* jointA.c: Conqrun implementation of routines defined for both sections */

/* BIND_FUNC -- return a string name for the given function */
extern char * bind_func PL_(( int which ));

/* CHECK_SPELLS -- Implement the spell list */
extern void check_spells PL_(( int spellnum, int xloc, int yloc ));

/* DFLT_DISP_SETUP -- Build up one of the settings of the default display */
extern void dflt_disp_setup PL_(( char * str, char * fstr, int lnum ));

/* DISPLAY_SETUP -- Configure the display modes */
extern void display_setup PL_(( char * str, char * fstr, int lnum ));

/* HANGUP -- signal catching routine */
extern void hangup PL_(( int sig ));

/* KEYSYS_SETUP -- Configure the keybindings */
extern void keysys_setup PL_(( int type, char * str, char * fstr, int lnum ));

#undef PL_
#endif /* __CEXTRACT__ */
